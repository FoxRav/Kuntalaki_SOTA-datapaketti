from pathlib import Path
from lxml import etree
import sys, re

def norm(s: str) -> str:
    s = re.sub(r"[ \t]+", " ", s)
    s = re.sub(r"\n{3,}", "\n\n", s)
    return s.strip()

def txt(node) -> str:
    return norm(" ".join(" ".join(node.itertext()).split()))

def first(node, name):
    x = node.xpath(f"./*[local-name()='{name}'][1]")
    return txt(x[0]) if x else ""

def md_heading(level, s):
    return f"{'#'*level} {s}".strip()

def render_block(node, out, indent=0):
    tag = etree.QName(node).localname

    # Lista: renderöi vain itemit (ei tuplaa itemien sisätekstiä muissa haaroissa)
    if tag == "list":
        items = node.xpath("./*[local-name()='item']")
        for it in items:
            # label esim "1)" voi olla <label>
            label = first(it, "label")
            # itemin sisältö: usein <p> + mahdollisia alilistoja
            ps = it.xpath("./*[local-name()='p']")
            head = txt(ps[0]) if ps else txt(it)  # fallback
            bullet = f"{'  '*indent}- " + (f"**{label}** " if label else "") + head
            out.append(bullet)

            # mahdollinen alilista
            sublists = it.xpath("./*[local-name()='list']")
            for sl in sublists:
                render_block(sl, out, indent=indent+1)
        out.append("")
        return

    # Pykälä / artikla
    if tag in ("section", "article"):
        num = first(node, "num")
        heading = first(node, "heading")
        h = " ".join([x for x in [num, heading] if x])
        if h:
            out.append(md_heading(3, h))
            out.append("")

        # Renderöi vain suorat p-kappaleet ja listat tässä solmussa (estää tuplia)
        for ch in node.xpath("./*"):
            ctag = etree.QName(ch).localname
            if ctag == "p":
                t = txt(ch)
                if t:
                    out.append(t)
                    out.append("")
            elif ctag == "list":
                render_block(ch, out, indent=0)
        return

    # Luku / osa
    if tag in ("chapter", "part", "book"):
        num = first(node, "num")
        heading = first(node, "heading")
        h = " ".join([x for x in [num, heading] if x])
        if h:
            out.append(md_heading(2, h))
            out.append("")
        # käsittele vain suorat alielementit
        for ch in node.xpath("./*"):
            render_block(ch, out, indent=0)
        return

    # Muut: käy läpi alielementit
    for ch in node.xpath("./*"):
        render_block(ch, out, indent=indent)

def main(inp, outp):
    tree = etree.parse(inp)
    root = tree.getroot()

    body = root.xpath("//*[local-name()='body'][1]")
    if not body:
        raise SystemExit("BODY ei löytynyt.")
    body = body[0]

    out = []

    # Otsikko jos löytyy
    title = root.xpath("//*[local-name()='docTitle']//*[local-name()='p'][1]")
    if title:
        out.append("# " + txt(title[0]))
        out.append("")

    # Käy läpi bodyn suorat lapset
    for ch in body.xpath("./*"):
        render_block(ch, out, indent=0)

    Path(outp).write_text("\n".join(out).rstrip() + "\n", encoding="utf-8-sig")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Käyttö: python akn_to_md_v2.py <input_main.xml> <output.md>")
        raise SystemExit(2)
    main(sys.argv[1], sys.argv[2])
